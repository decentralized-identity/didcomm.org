{
    "componentChunkName": "component---src-templates-book-book-tsx",
    "path": "/book/v2/helloworldpy",
    "result": {"data":{"markdownRemark":{"html":"<h2 id=\"Hello-World-in-Python\">\"Hello World\" in Python</h2>\n<p>This simple \"Hello World\" example shows how Alice can create an encrypted message to Bob. In that case, we are using <a href=\"https://github.com/sicpa-dlab/didcomm-python\">DIDComm Python</a> and <a href=\"https://github.com/sicpa-dlab/peer-did-python\">Peerdid Python</a> libraries from <a href=\"https://www.sicpa.com\">SICPA</a>.</p>\n<h3 id=\"Step-1-Install-packages\">Step 1: Install packages</h3>\n<p>Once you set up your python environment, you need to install the following packages:</p>\n<pre><code>pip install didcomm\npip install peerdid\npip install json\n</code></pre>\n<p>The code in the following sections can be executed in a single python file or executed online in this <a href=\"https://mybinder.org/v2/gh/rodolfomiranda/didcomm-hello-world-py/HEAD?labpath=HelloWorld.ipynb\">Binder interactive Jupyter notebook</a>.</p>\n<h3 id=\"Step-2-Imports\">Step 2: Imports</h3>\n<p>First, we need to import all required functions, clases and types from <code>didcomm</code> and <code>peerdid</code> libraries as follows:</p>\n<pre><code>from didcomm.common.types import DID, VerificationMethodType, VerificationMaterial, VerificationMaterialFormat\nfrom didcomm.did_doc.did_doc import DIDDoc, VerificationMethod, DIDCommService\nfrom didcomm.did_doc.did_resolver import DIDResolver\nfrom didcomm.message import Message\nfrom didcomm.secrets.secrets_resolver_demo import SecretsResolverDemo\nfrom didcomm.unpack import unpack, UnpackResult\nfrom didcomm.common.resolvers import ResolversConfig\nfrom didcomm.pack_encrypted import pack_encrypted, PackEncryptedConfig, PackEncryptedResult\nfrom didcomm.secrets.secrets_util import generate_x25519_keys_as_jwk_dict, generate_ed25519_keys_as_jwk_dict, jwk_to_secret\nfrom peerdid import peer_did\nfrom peerdid.did_doc import DIDDocPeerDID\nfrom peerdid.types import VerificationMaterialAuthentication, VerificationMethodTypeAuthentication, VerificationMaterialAgreement, VerificationMethodTypeAgreement, VerificationMaterialFormatPeerDID\nimport json\n</code></pre>\n<h3 id=\"Step-3-Resolvers\">Step 3: Resolvers</h3>\n<p>In this step we add two Resolvers needed by DIDComm and the libraries:</p>\n<p><strong>Secret resolver:</strong></p>\n<p>This sample code needs a storage to keep the generated key pair secrets. It will then be referenced by the library as a <code>secrets_resolver</code>. We can instantiate it as follows:\n<code>secrets_resolver = SecretsResolverDemo()</code>\nNote that the <code>SecretsResolverDemo</code> simply stores the keys in a text file named <code>secrets.json</code>. As you've just realized, this secret storage is anything but secure. Keep in mind that securing keys is of utmost importance for a self-sovereign identity; never use it in production.</p>\n<p><strong>DID Resolver:</strong></p>\n<p>DIDComm only works if your code knows how to resolve DIDs to DID documents. There are various libraries that provide that feature. For example, the <a href=\"https://github.com/decentralized-identity/universal-resolver\">Universal Resolver</a> can be used. In this walk-through, we'll provide a simple stub that minimizes dependencies and keeps things as simple as possible. Click <a href=\"https://mybinder.org/v2/gh/rodolfomiranda/didcomm-hello-world-py/HEAD?labpath=HelloWorld.ipynb\">here</a> for full example where you'll find the code that do the trick.</p>\n<h3 id=\"Step-4-Create-DIDs\">Step 4: Create DIDs</h3>\n<p>Using <code>create_simple_peer_did</code> helper function, Alice and Bob can create their DID Peer that they will share and use when communicating privately between each other. This function creates a basic DID Peer with only one Agreement key, one Authentication key, and no Service part. You can find the helper function and the full code <a href=\"https://mybinder.org/v2/gh/rodolfomiranda/didcomm-hello-world-py/HEAD?labpath=HelloWorld.ipynb\">here</a>.</p>\n<pre><code>alice_did = await create_simple_peer_did()\nprint(\"Alice's DID:\", alice_did)\nbob_did = await create_simple_peer_did()\nprint(\"Bob's DID:\", bob_did)\n</code></pre>\n<p>You should get something similar to:</p>\n<pre><code>Alice's DID: did:peer:2.Ez6LSt4Jscr227NFyuzKHT85haVE4AFVXm1tDwYeZ5xenxMmW.Vz6MkfvwnoNS6Cto38MEMbqdnypVDN7gS4oAMaHFkjAUse5JE\nBob's DID: did:peer:2.Ez6LSetXDUvD8rBSei5TU5ew7VRdWyNBr5mAsxr6EoHFTxt9f.Vz6Mkty3Nu98rnrHfk1GBCurF7EFKY5Vb34FAJNJCMhwzduk3\n</code></pre>\n<p>Remember that while creating these simple DIDs, our helper function also stores the private keys in the <code>secrets_resolver</code>. In a real implementation, Alice will have her own secure store in her own wallet, and Bob will have a separated secure store in his own wallet.\nAlso, those Peer DIDs can be resolved into DID documents that contain the <em>Authentication</em> and <em>Agreement</em> public keys.</p>\n<h3 id=\"Step-5-Encrypt-and-pack-the-message\">Step 5: Encrypt and pack the message</h3>\n<p>Alice can create a simple \"Hello World\" message with:</p>\n<pre><code>message = Message(\n    body = {\"msg\": \"Hello World\"},\n    id = \"unique-id-24160d23ed1d\",\n    type = \"my-protocol/1.0\",\n    frm = alice_did,\n    to = [bob_did]\n)\n</code></pre>\n<p>Note that the message includes an <code>id</code> that is mandatory and has to be unique to Alice. Also includes a <code>type</code>, also mandatory, that points to the protocol identifier that we've just invented. The <code>body</code> contains the actual message in an structured way associated by our <code>my-protocol/1.0</code>. Attributes <code>from</code> and <code>to</code> are optional. Beware that in the code above the property <code>from</code> was replaced by <code>frm</code> due to a conflict of reserved words in Python; the conversion to the correct property (<code>from</code>) is handled internally by the library.</p>\n<p><a href=\"https://identity.foundation/didcomm-messaging/spec/v2.0/#message-formats\">DIDComm</a> defines three message formats: plaintext, signed, and encrypted. We are going to use the latter since it is the most common for most applications. In that case, the message will be encrypted so only Bob can see it.\nThe final packed message can be generated with this code:</p>\n<pre><code>packed_msg = await pack_encrypted(\n    resolvers_config = ResolversConfig(\n        secrets_resolver = secrets_resolver,\n        did_resolver = DIDResolverPeerDID()\n    ),\n    message = message,\n    frm = alice_did,\n    to = bob_did,\n    sign_frm = None,\n    pack_config = PackEncryptedConfig(protect_sender_id=False)\n)\n</code></pre>\n<p>This library also offers the option of anonymous encryption, encryption with no repudation, and message signing. Note also that we pass a resolver configuration pointing to our secrets store and the DID resolver.\nIf you take a look at the packed message, you'll see that the content was hidden in the encryption:</p>\n<pre><code>print(packed_msg.packed_msg[:200]+\"...\")\n</code></pre>\n<p><code>{\"protected\":\"eyJ0eXAiOiJhcHBsaWNhdGlvbi9kaWRjb21tLWVuY3J5cHRlZCtqc29uIiwiYWxnIjoiRUNESC0xUFUrQTI1NktXIiwiZW5jIjoiQTI1NkNCQy1IUzUxMiIsImFwdSI6IlpHbGtPbkJsWlhJNk1pNUZlalpNVTNJM1pWaFlObXBxYjI0MFpFVmFWaz...</code></p>\n<h3 id=\"Step-6-Receive-and-unpack-the-message\">Step 6: Receive and unpack the message</h3>\n<p>Alice will send the packed message to Bob using a transport. Once received, Bob can unpack it with the following code:</p>\n<pre><code>unpack_msg = await unpack(\n    resolvers_config=ResolversConfig(\n        secrets_resolver=secrets_resolver,\n        did_resolver=DIDResolverPeerDID()\n    ),\n    packed_msg=packed_msg.packed_msg\n)\n</code></pre>\n<p>Note that we also passed the resolver config as before.\nFinally, Bob can see Alice's message by:</p>\n<pre><code>print(unpack_msg.message.body[\"msg\"])\n</code></pre>\n<p><code>Hello World</code></p>"}},"pageContext":{"id":"0800ecea-f4d4-53c0-94ef-35b014b02c26","html":"<h2 id=\"Hello-World-in-Python\">\"Hello World\" in Python</h2>\n<p>This simple \"Hello World\" example shows how Alice can create an encrypted message to Bob. In that case, we are using <a href=\"https://github.com/sicpa-dlab/didcomm-python\">DIDComm Python</a> and <a href=\"https://github.com/sicpa-dlab/peer-did-python\">Peerdid Python</a> libraries from <a href=\"https://www.sicpa.com\">SICPA</a>.</p>\n<h3 id=\"Step-1-Install-packages\">Step 1: Install packages</h3>\n<p>Once you set up your python environment, you need to install the following packages:</p>\n<pre><code>pip install didcomm\npip install peerdid\npip install json\n</code></pre>\n<p>The code in the following sections can be executed in a single python file or executed online in this <a href=\"https://mybinder.org/v2/gh/rodolfomiranda/didcomm-hello-world-py/HEAD?labpath=HelloWorld.ipynb\">Binder interactive Jupyter notebook</a>.</p>\n<h3 id=\"Step-2-Imports\">Step 2: Imports</h3>\n<p>First, we need to import all required functions, clases and types from <code>didcomm</code> and <code>peerdid</code> libraries as follows:</p>\n<pre><code>from didcomm.common.types import DID, VerificationMethodType, VerificationMaterial, VerificationMaterialFormat\nfrom didcomm.did_doc.did_doc import DIDDoc, VerificationMethod, DIDCommService\nfrom didcomm.did_doc.did_resolver import DIDResolver\nfrom didcomm.message import Message\nfrom didcomm.secrets.secrets_resolver_demo import SecretsResolverDemo\nfrom didcomm.unpack import unpack, UnpackResult\nfrom didcomm.common.resolvers import ResolversConfig\nfrom didcomm.pack_encrypted import pack_encrypted, PackEncryptedConfig, PackEncryptedResult\nfrom didcomm.secrets.secrets_util import generate_x25519_keys_as_jwk_dict, generate_ed25519_keys_as_jwk_dict, jwk_to_secret\nfrom peerdid import peer_did\nfrom peerdid.did_doc import DIDDocPeerDID\nfrom peerdid.types import VerificationMaterialAuthentication, VerificationMethodTypeAuthentication, VerificationMaterialAgreement, VerificationMethodTypeAgreement, VerificationMaterialFormatPeerDID\nimport json\n</code></pre>\n<h3 id=\"Step-3-Resolvers\">Step 3: Resolvers</h3>\n<p>In this step we add two Resolvers needed by DIDComm and the libraries:</p>\n<p><strong>Secret resolver:</strong></p>\n<p>This sample code needs a storage to keep the generated key pair secrets. It will then be referenced by the library as a <code>secrets_resolver</code>. We can instantiate it as follows:\n<code>secrets_resolver = SecretsResolverDemo()</code>\nNote that the <code>SecretsResolverDemo</code> simply stores the keys in a text file named <code>secrets.json</code>. As you've just realized, this secret storage is anything but secure. Keep in mind that securing keys is of utmost importance for a self-sovereign identity; never use it in production.</p>\n<p><strong>DID Resolver:</strong></p>\n<p>DIDComm only works if your code knows how to resolve DIDs to DID documents. There are various libraries that provide that feature. For example, the <a href=\"https://github.com/decentralized-identity/universal-resolver\">Universal Resolver</a> can be used. In this walk-through, we'll provide a simple stub that minimizes dependencies and keeps things as simple as possible. Click <a href=\"https://mybinder.org/v2/gh/rodolfomiranda/didcomm-hello-world-py/HEAD?labpath=HelloWorld.ipynb\">here</a> for full example where you'll find the code that do the trick.</p>\n<h3 id=\"Step-4-Create-DIDs\">Step 4: Create DIDs</h3>\n<p>Using <code>create_simple_peer_did</code> helper function, Alice and Bob can create their DID Peer that they will share and use when communicating privately between each other. This function creates a basic DID Peer with only one Agreement key, one Authentication key, and no Service part. You can find the helper function and the full code <a href=\"https://mybinder.org/v2/gh/rodolfomiranda/didcomm-hello-world-py/HEAD?labpath=HelloWorld.ipynb\">here</a>.</p>\n<pre><code>alice_did = await create_simple_peer_did()\nprint(\"Alice's DID:\", alice_did)\nbob_did = await create_simple_peer_did()\nprint(\"Bob's DID:\", bob_did)\n</code></pre>\n<p>You should get something similar to:</p>\n<pre><code>Alice's DID: did:peer:2.Ez6LSt4Jscr227NFyuzKHT85haVE4AFVXm1tDwYeZ5xenxMmW.Vz6MkfvwnoNS6Cto38MEMbqdnypVDN7gS4oAMaHFkjAUse5JE\nBob's DID: did:peer:2.Ez6LSetXDUvD8rBSei5TU5ew7VRdWyNBr5mAsxr6EoHFTxt9f.Vz6Mkty3Nu98rnrHfk1GBCurF7EFKY5Vb34FAJNJCMhwzduk3\n</code></pre>\n<p>Remember that while creating these simple DIDs, our helper function also stores the private keys in the <code>secrets_resolver</code>. In a real implementation, Alice will have her own secure store in her own wallet, and Bob will have a separated secure store in his own wallet.\nAlso, those Peer DIDs can be resolved into DID documents that contain the <em>Authentication</em> and <em>Agreement</em> public keys.</p>\n<h3 id=\"Step-5-Encrypt-and-pack-the-message\">Step 5: Encrypt and pack the message</h3>\n<p>Alice can create a simple \"Hello World\" message with:</p>\n<pre><code>message = Message(\n    body = {\"msg\": \"Hello World\"},\n    id = \"unique-id-24160d23ed1d\",\n    type = \"my-protocol/1.0\",\n    frm = alice_did,\n    to = [bob_did]\n)\n</code></pre>\n<p>Note that the message includes an <code>id</code> that is mandatory and has to be unique to Alice. Also includes a <code>type</code>, also mandatory, that points to the protocol identifier that we've just invented. The <code>body</code> contains the actual message in an structured way associated by our <code>my-protocol/1.0</code>. Attributes <code>from</code> and <code>to</code> are optional. Beware that in the code above the property <code>from</code> was replaced by <code>frm</code> due to a conflict of reserved words in Python; the conversion to the correct property (<code>from</code>) is handled internally by the library.</p>\n<p><a href=\"https://identity.foundation/didcomm-messaging/spec/v2.0/#message-formats\">DIDComm</a> defines three message formats: plaintext, signed, and encrypted. We are going to use the latter since it is the most common for most applications. In that case, the message will be encrypted so only Bob can see it.\nThe final packed message can be generated with this code:</p>\n<pre><code>packed_msg = await pack_encrypted(\n    resolvers_config = ResolversConfig(\n        secrets_resolver = secrets_resolver,\n        did_resolver = DIDResolverPeerDID()\n    ),\n    message = message,\n    frm = alice_did,\n    to = bob_did,\n    sign_frm = None,\n    pack_config = PackEncryptedConfig(protect_sender_id=False)\n)\n</code></pre>\n<p>This library also offers the option of anonymous encryption, encryption with no repudation, and message signing. Note also that we pass a resolver configuration pointing to our secrets store and the DID resolver.\nIf you take a look at the packed message, you'll see that the content was hidden in the encryption:</p>\n<pre><code>print(packed_msg.packed_msg[:200]+\"...\")\n</code></pre>\n<p><code>{\"protected\":\"eyJ0eXAiOiJhcHBsaWNhdGlvbi9kaWRjb21tLWVuY3J5cHRlZCtqc29uIiwiYWxnIjoiRUNESC0xUFUrQTI1NktXIiwiZW5jIjoiQTI1NkNCQy1IUzUxMiIsImFwdSI6IlpHbGtPbkJsWlhJNk1pNUZlalpNVTNJM1pWaFlObXBxYjI0MFpFVmFWaz...</code></p>\n<h3 id=\"Step-6-Receive-and-unpack-the-message\">Step 6: Receive and unpack the message</h3>\n<p>Alice will send the packed message to Bob using a transport. Once received, Bob can unpack it with the following code:</p>\n<pre><code>unpack_msg = await unpack(\n    resolvers_config=ResolversConfig(\n        secrets_resolver=secrets_resolver,\n        did_resolver=DIDResolverPeerDID()\n    ),\n    packed_msg=packed_msg.packed_msg\n)\n</code></pre>\n<p>Note that we also passed the resolver config as before.\nFinally, Bob can see Alice's message by:</p>\n<pre><code>print(unpack_msg.message.body[\"msg\"])\n</code></pre>\n<p><code>Hello World</code></p>"}},
    "staticQueryHashes": ["3000541721"]}