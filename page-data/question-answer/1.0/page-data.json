{
    "componentChunkName": "component---src-templates-protocol-protocol-tsx",
    "path": "/question-answer/1.0/",
    "result": {"data":{"markdownRemark":{"html":"<h2 id=\"Details\">Details</h2>\n<p>This protocol was first defined at <a href=\"https://github.com/hyperledger/aries-rfcs/tree/main/features/0113-question-answer\">https://github.com/hyperledger/aries-rfcs/tree/main/features/0113-question-answer</a>, and now adapted here with examples with DIDComm headers.</p>\n<h2 id=\"Summary\">Summary</h2>\n<p>A simple protocol where a questioner asks a responder a question with at least one valid answer. The responder then replies with an answer or ignores the question.</p>\n<blockquote>\n<p>Note: While there is a need in the future for a robust negotiation protocol</p>\n</blockquote>\n<p>this is not it. This is for simple question/answer exchanges.</p>\n<h2 id=\"Motivation\">Motivation</h2>\n<p>There are many instances where one party needs an answer to a specific question from another party. These can be related to consent, proof of identity, authentication, or choosing from a list of options. For example, when receiving a phone call a customer service representative can ask a question to the customer’s phone to authenticate the caller, “Are you on the phone with our representative?”. The same could be done to authorize transactions, validate logins (2FA), accept terms and conditions, and any other simple, non-negotiable exchanges.</p>\n<h2 id=\"Interaction\">Interaction</h2>\n<p>We'll describe this protocol in terms of a <a href=\"https://en.wikipedia.org/wiki/Challenge%E2%80%93response_authentication\">Challenge/Response</a> scenario where a customer service representative for Faber Bank questions its customer Alice, who is speaking with them on the phone, to answer whether it is really her.</p>\n<p>Using an already established pairwise connection and agent-to-agent communication Faber will send a question to Alice with one or more valid responses with an optional deadline and Alice can select one of the valid responses or ignore the question. If she selects one of the valid responses she will respond with her answer.</p>\n<h2 id=\"Roles\">Roles</h2>\n<p>There are two parties in a typical question/answer interaction. The first party, <code>questioner</code>, issues the question with its valid answers and the second party, <code>responder</code>, responds with the selected answer. The parties must have already exchanged pairwise keys and created a connection. These pairwise can be used to encrypt and verify the response. When the answer has been sent questioner can know with a high level of certainty that it was sent by responder.</p>\n<p>In this tutorial Faber (the <code>questioner</code>) initiates the interaction and creates and sends the question to Alice. The question includes the valid responses, which can optionally be signed for non-repudiability.</p>\n<p>In this tutorial Alice (the <code>responder</code>) receives the packet and must respond to the question (or ignore it, which is not an answer) by encrypting either the positive or the negative response_code (signing both is invalid).</p>\n<h2 id=\"Message-Reference\">Message Reference</h2>\n<h3 id=\"Question\">Question</h3>\n<p>The protocol begins when the <code>questioner</code> sends a <code>question</code> message to the responder:</p>\n<p>DIDComm V1 Example:</p>\n<pre><code>{\n  \"@type\": \"https://didcomm.org/questionanswer/1.0/question\",\n  \"@id\": \"518be002-de8e-456e-b3d5-8fe472477a86\",\n  \"question_text\": \"Alice, are you on the phone with Bob from Faber Bank right now?\",\n  \"question_detail\": \"This is optional fine-print giving context to the question and its various answers.\",\n  \"nonce\": \"&#x3C;valid_nonce>\",\n  \"signature_required\": true,\n  \"valid_responses\" : [\n    {\"text\": \"Yes, it's me\"},\n    {\"text\": \"No, that's not me!\"}],\n  \"~timing\": {\n    \"expires_time\": \"2018-12-13T17:29:06+0000\"\n  }\n}\n</code></pre>\n<p>DIDComm V2 Example:</p>\n<pre><code>{\n  \"type\": \"https://didcomm.org/questionanswer/1.0/question\",\n  \"id\": \"518be002-de8e-456e-b3d5-8fe472477a86\",\n  \"body\": {\n        \"question_text\": \"Alice, are you on the phone with Bob from Faber Bank right now?\",\n        \"question_detail\": \"This is optional fine-print giving context to the question and its various answers.\",\n        \"nonce\": \"&#x3C;valid_nonce>\",\n        \"signature_required\": true,\n        \"valid_responses\" : [\n            {\"text\": \"Yes, it's me\"},\n            {\"text\": \"No, that's not me!\"}\n        ],\n        \"expires_time\": 1544722146\n  }\n}\n</code></pre>\n<ul>\n<li><code>question_detail</code> is optional. It can be used to give \"fine print\"-like context around the question and all of its valid responses. While this could always be displayed, some UIs may choose to only make it available on-demand, in a \"More info...\" kind of way.</li>\n<li><code>expires_time</code> is optional</li>\n</ul>\n<h3 id=\"Answer\">Answer</h3>\n<p>The <code>responder</code> receives this message and chooses the answer. If the signature is required then she uses her private pairwise key to sign her response.</p>\n<blockquote>\n<p>Note: Alice should sign the following: the question, the chosen answer,</p>\n</blockquote>\n<p>and the nonce: HASH(&#x3C;question_text>+&#x3C;answer_text>+<nonce>), this keeps a\nrecord of each part of the transaction.</p>\n<p>DIDComm V1 Example:</p>\n<pre><code>{\n  \"@type\": \"https://didcomm.org/questionanswer/1.0/answer\",\n  \"~thread\": { \"thid\": \"518be002-de8e-456e-b3d5-8fe472477a86\", \"seqnum\": 0 },\n  \"response\": \"Yes, it's me\",\n  \"response~sig\": {\n    \"@type\": \"https://didcomm.org/signature/1.0/ed25519Sha512_single\"\n    \"signature\": \"&#x3C;digital signature function output>\",\n    \"sig_data\": \"&#x3C;base64url(HASH(\"Alice, are you on the phone with Bob?\"+\"Yes, it's me\"+\"&#x3C;nonce>\"))>\",\n    \"signers\": [\"&#x3C;responder_key>\"],\n    }\n  \"~timing\": {\n    \"out_time\": \"2018-12-13T17:29:34+0000\"\n  }\n}\n</code></pre>\n<p>DIDComm V2 Example:</p>\n<pre><code>{\n    \"type\": \"https://didcomm.org/questionanswer/1.0/answer\",\n    \"id\": \"5b6ae361-d4d0-4ca7-b7d7-cdfafc2ebc1d\"\n    \"thid\": \"518be002-de8e-456e-b3d5-8fe472477a86\",\n    \"created_time\": 1544722103,\n    \"body\": {\n        \"response\": \"Yes, it's me\",\n        \"response_sig\": {\n            \"type\": \"https://didcomm.org/signature/1.0/ed25519Sha512_single\"\n            \"signature\": \"&#x3C;digital signature function output>\",\n            \"sig_data\": \"&#x3C;base64url(HASH(\"Alice, are you on the phone with Bob?\"+\"Yes, it's me\"+\"&#x3C;nonce>\"))>\",\n            \"signers\": [\"&#x3C;responder_key>\"],\n        }\n    }\n}\n</code></pre>\n<p><code>response_sig</code> is optional when <code>signature_required</code> is false</p>\n<p>The questioner then checks the signature against the sig_data.</p>\n<h2 id=\"Business-cases-and-auditing\">Business cases and auditing</h2>\n<p>In the above scenario, Faber bank can audit the reply and prove that only Alice's pairwise key signed the response (a cryptographic API like Indy-SDK can be used to guarantee the responder's signature). Conversely, Alice can also use her key to prove or dispute the validity of the signature. The cryptographic guarantees central to agent-to-agent communication and digital signatures create a trustworthy protocol for obtaining a committed answer from a pairwise connection. This protocol can be used for approving wire transfers, accepting EULAs, or even selecting an item from a food menu. Of course, as with a real world signature, Alice should be careful about what she signs.</p>\n<h2 id=\"Invalid-replies\">Invalid replies</h2>\n<p>The responder may send an invalid, incomplete, or unsigned response. In this case the questioner must decide what to do. As with normal verbal communication, if the response is not understood the question can be asked again, maybe with increased emphasis. Or the questioner may determine the lack of a valid response is a response in and of itself. This depends on the parties involved and the question being asked. For example, in the exchange above, if the question times out or the answer is not \"Yes, it's me\" then Faber would probably choose to discontinue the phone call.</p>\n<h2 id=\"Trust-and-Constraints\">Trust and Constraints</h2>\n<p>Using already established pairwise relationships allows each side to trust each other. The responder can know who sent the message and the questioner knows that only the responder could have encrypted the response. This response gives a high level of trust to the exchange.</p>\n<h2 id=\"Implementations\">Implementations</h2>\n<table>\n<thead>\n<tr>\n<th>Name / Link</th>\n<th>DIDComm version</th>\n<th>Implementation Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://www.evernym.com/blog/connect-me-sovrin-digital-wallet/\">Connect.Me</a></td>\n<td>v1</td>\n<td>Free mobile app from Evernym. Installed via app store on iOS and Android.</td>\n</tr>\n<tr>\n<td><a href=\"https://www.evernym.com/products/\">Verity</a></td>\n<td>v1</td>\n<td>Commercially licensed enterprise agent, SaaS or on-prem.</td>\n</tr>\n</tbody>\n</table>","frontmatter":{"title":"Question Answer","tags":[],"license":"MIT","publisher":"rodolfomiranda","status":"Production","piuri":"https://didcomm.org/questionanswer/1.0","summary":"A simple protocol where a questioner asks a responder a question with at least one valid answer. The responder then replies with an answer or ignores the question.","authors":[{"name":"Douglas Wightman","email":"douglas.wightman@evernym.com"}]},"fields":{"modifiedDate":"Mon Mar 17 2025 19:26:22 GMT+0000 (Coordinated Universal Time)","avatar":"https://avatars.githubusercontent.com/u/2913773?v=4&s=48","version":"1.0"}}},"pageContext":{"matchPath":"question-answer/1.0/*","id":"d34c4525-a066-56fa-862e-05eddb554dd0","html":"<h2 id=\"Details\">Details</h2>\n<p>This protocol was first defined at <a href=\"https://github.com/hyperledger/aries-rfcs/tree/main/features/0113-question-answer\">https://github.com/hyperledger/aries-rfcs/tree/main/features/0113-question-answer</a>, and now adapted here with examples with DIDComm headers.</p>\n<h2 id=\"Summary\">Summary</h2>\n<p>A simple protocol where a questioner asks a responder a question with at least one valid answer. The responder then replies with an answer or ignores the question.</p>\n<blockquote>\n<p>Note: While there is a need in the future for a robust negotiation protocol</p>\n</blockquote>\n<p>this is not it. This is for simple question/answer exchanges.</p>\n<h2 id=\"Motivation\">Motivation</h2>\n<p>There are many instances where one party needs an answer to a specific question from another party. These can be related to consent, proof of identity, authentication, or choosing from a list of options. For example, when receiving a phone call a customer service representative can ask a question to the customer’s phone to authenticate the caller, “Are you on the phone with our representative?”. The same could be done to authorize transactions, validate logins (2FA), accept terms and conditions, and any other simple, non-negotiable exchanges.</p>\n<h2 id=\"Interaction\">Interaction</h2>\n<p>We'll describe this protocol in terms of a <a href=\"https://en.wikipedia.org/wiki/Challenge%E2%80%93response_authentication\">Challenge/Response</a> scenario where a customer service representative for Faber Bank questions its customer Alice, who is speaking with them on the phone, to answer whether it is really her.</p>\n<p>Using an already established pairwise connection and agent-to-agent communication Faber will send a question to Alice with one or more valid responses with an optional deadline and Alice can select one of the valid responses or ignore the question. If she selects one of the valid responses she will respond with her answer.</p>\n<h2 id=\"Roles\">Roles</h2>\n<p>There are two parties in a typical question/answer interaction. The first party, <code>questioner</code>, issues the question with its valid answers and the second party, <code>responder</code>, responds with the selected answer. The parties must have already exchanged pairwise keys and created a connection. These pairwise can be used to encrypt and verify the response. When the answer has been sent questioner can know with a high level of certainty that it was sent by responder.</p>\n<p>In this tutorial Faber (the <code>questioner</code>) initiates the interaction and creates and sends the question to Alice. The question includes the valid responses, which can optionally be signed for non-repudiability.</p>\n<p>In this tutorial Alice (the <code>responder</code>) receives the packet and must respond to the question (or ignore it, which is not an answer) by encrypting either the positive or the negative response_code (signing both is invalid).</p>\n<h2 id=\"Message-Reference\">Message Reference</h2>\n<h3 id=\"Question\">Question</h3>\n<p>The protocol begins when the <code>questioner</code> sends a <code>question</code> message to the responder:</p>\n<p>DIDComm V1 Example:</p>\n<pre><code>{\n  \"@type\": \"https://didcomm.org/questionanswer/1.0/question\",\n  \"@id\": \"518be002-de8e-456e-b3d5-8fe472477a86\",\n  \"question_text\": \"Alice, are you on the phone with Bob from Faber Bank right now?\",\n  \"question_detail\": \"This is optional fine-print giving context to the question and its various answers.\",\n  \"nonce\": \"&lt;valid_nonce&gt;\",\n  \"signature_required\": true,\n  \"valid_responses\" : [\n    {\"text\": \"Yes, it's me\"},\n    {\"text\": \"No, that's not me!\"}],\n  \"~timing\": {\n    \"expires_time\": \"2018-12-13T17:29:06+0000\"\n  }\n}\n</code></pre>\n<p>DIDComm V2 Example:</p>\n<pre><code>{\n  \"type\": \"https://didcomm.org/questionanswer/1.0/question\",\n  \"id\": \"518be002-de8e-456e-b3d5-8fe472477a86\",\n  \"body\": {\n        \"question_text\": \"Alice, are you on the phone with Bob from Faber Bank right now?\",\n        \"question_detail\": \"This is optional fine-print giving context to the question and its various answers.\",\n        \"nonce\": \"&lt;valid_nonce&gt;\",\n        \"signature_required\": true,\n        \"valid_responses\" : [\n            {\"text\": \"Yes, it's me\"},\n            {\"text\": \"No, that's not me!\"}\n        ],\n        \"expires_time\": 1544722146\n  }\n}\n</code></pre>\n<ul>\n<li><code>question_detail</code> is optional. It can be used to give \"fine print\"-like context around the question and all of its valid responses. While this could always be displayed, some UIs may choose to only make it available on-demand, in a \"More info...\" kind of way.</li>\n<li><code>expires_time</code> is optional</li>\n</ul>\n<h3 id=\"Answer\">Answer</h3>\n<p>The <code>responder</code> receives this message and chooses the answer. If the signature is required then she uses her private pairwise key to sign her response.</p>\n<blockquote>\n<p>Note: Alice should sign the following: the question, the chosen answer,</p>\n</blockquote>\n<p>and the nonce: HASH(&lt;question_text&gt;+&lt;answer_text&gt;+&lt;nonce&gt;), this keeps a\nrecord of each part of the transaction.&lt;/nonce&gt;</p>\n<p>DIDComm V1 Example:</p>\n<pre><code>{\n  \"@type\": \"https://didcomm.org/questionanswer/1.0/answer\",\n  \"~thread\": { \"thid\": \"518be002-de8e-456e-b3d5-8fe472477a86\", \"seqnum\": 0 },\n  \"response\": \"Yes, it's me\",\n  \"response~sig\": {\n    \"@type\": \"https://didcomm.org/signature/1.0/ed25519Sha512_single\"\n    \"signature\": \"&lt;digital signature function output&gt;\",\n    \"sig_data\": \"&lt;base64url(HASH(\"Alice, are you on the phone with Bob?\"+\"Yes, it's me\"+\"&lt;nonce&gt;\"))&gt;\",\n    \"signers\": [\"&lt;responder_key&gt;\"],\n    }\n  \"~timing\": {\n    \"out_time\": \"2018-12-13T17:29:34+0000\"\n  }\n}\n</code></pre>\n<p>DIDComm V2 Example:</p>\n<pre><code>{\n    \"type\": \"https://didcomm.org/questionanswer/1.0/answer\",\n    \"id\": \"5b6ae361-d4d0-4ca7-b7d7-cdfafc2ebc1d\"\n    \"thid\": \"518be002-de8e-456e-b3d5-8fe472477a86\",\n    \"created_time\": 1544722103,\n    \"body\": {\n        \"response\": \"Yes, it's me\",\n        \"response_sig\": {\n            \"type\": \"https://didcomm.org/signature/1.0/ed25519Sha512_single\"\n            \"signature\": \"&lt;digital signature function output&gt;\",\n            \"sig_data\": \"&lt;base64url(HASH(\"Alice, are you on the phone with Bob?\"+\"Yes, it's me\"+\"&lt;nonce&gt;\"))&gt;\",\n            \"signers\": [\"&lt;responder_key&gt;\"],\n        }\n    }\n}\n</code></pre>\n<p><code>response_sig</code> is optional when <code>signature_required</code> is false</p>\n<p>The questioner then checks the signature against the sig_data.</p>\n<h2 id=\"Business-cases-and-auditing\">Business cases and auditing</h2>\n<p>In the above scenario, Faber bank can audit the reply and prove that only Alice's pairwise key signed the response (a cryptographic API like Indy-SDK can be used to guarantee the responder's signature). Conversely, Alice can also use her key to prove or dispute the validity of the signature. The cryptographic guarantees central to agent-to-agent communication and digital signatures create a trustworthy protocol for obtaining a committed answer from a pairwise connection. This protocol can be used for approving wire transfers, accepting EULAs, or even selecting an item from a food menu. Of course, as with a real world signature, Alice should be careful about what she signs.</p>\n<h2 id=\"Invalid-replies\">Invalid replies</h2>\n<p>The responder may send an invalid, incomplete, or unsigned response. In this case the questioner must decide what to do. As with normal verbal communication, if the response is not understood the question can be asked again, maybe with increased emphasis. Or the questioner may determine the lack of a valid response is a response in and of itself. This depends on the parties involved and the question being asked. For example, in the exchange above, if the question times out or the answer is not \"Yes, it's me\" then Faber would probably choose to discontinue the phone call.</p>\n<h2 id=\"Trust-and-Constraints\">Trust and Constraints</h2>\n<p>Using already established pairwise relationships allows each side to trust each other. The responder can know who sent the message and the questioner knows that only the responder could have encrypted the response. This response gives a high level of trust to the exchange.</p>\n<h2 id=\"Implementations\">Implementations</h2>\n<table>\n<thead>\n<tr>\n<th>Name / Link</th>\n<th>DIDComm version</th>\n<th>Implementation Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://www.evernym.com/blog/connect-me-sovrin-digital-wallet/\">Connect.Me</a></td>\n<td>v1</td>\n<td>Free mobile app from Evernym. Installed via app store on iOS and Android.</td>\n</tr>\n<tr>\n<td><a href=\"https://www.evernym.com/products/\">Verity</a></td>\n<td>v1</td>\n<td>Commercially licensed enterprise agent, SaaS or on-prem.</td>\n</tr>\n</tbody>\n</table>"}},
    "staticQueryHashes": ["3000541721","3766577012"],
    "matchPath": "question-answer/1.0/*"}